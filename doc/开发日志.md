# TLI BD 决策辅助系统 - 开发日志

> 本文档记录项目开发过程中的核心决策、功能变更、遇到的问题及解决方案。
> 供后续 AI Agents 进行 Review 或项目重构时参考。

---

## 项目元信息

| 项目名称 | TLI BD 决策辅助系统 |
|---------|-------------------|
| 版本 | v0.4.0 |
| 创建日期 | 2024-12-09 |
| 最后更新 | 2024-12-13 |
| 规划文档 | `doc/火炬之光：无限 BD 决策辅助系统 - 开发规划 (V2.6).md` |

---

## 开发日志

### 2024-12-09: 项目初始化 (Agent A + Agent B)

#### 本次完成的工作

按照 V2.6 开发规划，完成了 **Agent A (数据库层)** 和 **Agent B (计算引擎)** 的基础实现。

**前端 UI (Agent C) 按要求暂缓开发。**

### 2025-01-07: 编译修复与本地验证

#### 处理事项
- 修复 `StatAggregator` 局部属性聚合的借用冲突：局部词缀直接作用于 `local_pool`，避免 clone 造成的无效修改。
- 清理未使用的导入并恢复转化规则中的 `StatPool` 引入，消除编译错误。
- 去除冗余 `mut`，保持代码整洁。
- 在可联网环境下执行 `cargo check` 已通过。

### 2025-12-09: 完整编译测试通过

#### 修复事项
- **ts-rs API 更新**：将 `export_all()` 改为 `export()`（ts-rs 7.x 版本变更）
- **武器攻速默认值**：修复 `calculate_rate` 函数中 `weapon.base_speed` 未设置时返回 0 导致 DPS 为 0 的问题，默认攻速改为 1.0
- **wasm-opt 兼容问题**：禁用 wasm-opt 优化器（旧版本不支持 bulk memory 操作）

#### 测试结果
- ✅ `cargo test`: 27/27 测试通过
- ✅ `wasm-pack build`: 成功生成 `tli_core.wasm`

#### 产出文件
```
pkg/
├── tli_core.wasm         # 核心 WASM 模块
├── tli_core.js           # JavaScript 胶水代码
├── tli_core.d.ts         # TypeScript 类型定义
├── tli_core_bg.wasm.d.ts # WASM 背景类型
└── package.json          # NPM 包配置
```

#### 仍存在的告警
- ts-rs 无法解析部分 `#[serde(default = "...")]` 属性（仅警告，不影响编译）

### 2024-12-11: 计算引擎 Bug 修复

#### Bug 1: `crit_zone` 计算公式 ✅ 已修复

**问题**：`build_multiplier_breakdown` 中 `crit_zone` 公式错误。

**语义确认**：`crit_multiplier = 1.5` 表示"150% 总暴击伤害"（非暴击为 100%）。

**修复**：
```rust
// 修复前 (错误)
let crit_zone = 1.0 + effective_crit_chance * crit_multiplier;

// 修复后 (正确)
let crit_zone = 1.0 + effective_crit_chance * (crit_multiplier - 1.0);
```

**示例验证**：
- 50% 暴击率，150% 暴击伤害
- 修复前: `1 + 0.5 * 1.5 = 1.75` ❌ (多算了 0.5)
- 修复后: `1 + 0.5 * 0.5 = 1.25` ✅

#### Bug 2: 缓存键缺失上下文数据 ⏸️ 暂缓

- **状态**：暂时忽略，待后续评估 `context_flags/values` 对计算的实际影响
- **原因**：当前条件计算逻辑尚未完全依赖这些值

---

### 2025-12-11: 核心天赋 & 机制扩展（已推送 Supabase）

#### 新增核心天赋（已 upsert 至 Supabase 项目 `tld`）
- **苦寒**：击中获得聚能祝福；聚能祝福上限 +1
- **积聚**：聚能祝福上限 +1；每层聚能祝福 +3% 法术伤害（per_focus_blessing）
- **世事无常**：物理最小伤害 -90%，物理最大伤害 +80%；全类型最小伤害 -40%，最大伤害 +40%（依赖 min/max More 乘区）
- **奇妙角度**：你造成的伤害“幸运”（两次取高值）

#### 计算引擎更新
- 支持按最小/最大值拆分的 More 乘区（含物理/全局 min/max 键）
- 支持 Lucky 期望伤害：`flag.lucky` 或 `context_flags.lucky_damage` 为真时，期望从 0.5 提升到 2/3
- 聚能祝福钩子：上限 +1、每层 +3% 法术伤害（per_xxx 机制生效）

#### 数据库同步
- 已通过 MCP 对 Supabase `tld` (`doemvsjyjzvtxaxaxhyl`) 执行 upsert：
  - `hero_traits`: 苦寒 / 积聚 / 世事无常 / 奇妙角度
  - `skills`: support_lightning_to_cold / support_electric_overload / support_psychic_burst
  - `skill_level_data`: 三个辅助技能 1-40 级真实数据（增伤/转化/迸发增伤）

---

### 2024-12-11: ZSim 架构优化借鉴

#### 背景

参考 ZSim（绝区零战斗模拟器）的核心仿真引擎架构，对 TLI 计算引擎进行优化：
- **乘区明细输出**：借鉴 ZSim 的 9 乘区分离设计
- **LRU 缓存机制**：借鉴 ZSim 的 MultiplierData 缓存策略

#### Phase 1: 乘区明细输出

**新增 `MultiplierBreakdown` 结构**：

```rust
pub struct MultiplierBreakdown {
    pub base_damage_zone: f64,    // 基础伤害区
    pub increased_zone: f64,      // 增伤区 (1 + sum(inc))
    pub more_zone: f64,           // More 乘区 (product of more)
    pub crit_zone: f64,           // 暴击期望区
    pub speed_zone: f64,          // 速度区
    pub hit_zone: f64,            // 命中区
    pub defense_zone: f64,        // 防御区 (敌人护甲)
    pub resistance_zone: f64,     // 抗性区
    pub vulnerability_zone: f64,  // 易伤区
    pub mechanics_zone: f64,      // 机制特殊区
    pub zone_sources: HashMap<String, Vec<ZoneSource>>, // 来源追踪
}
```

**用途**：
- 用户可清晰看到每个乘区的贡献
- 便于调试和验证计算过程
- 支持 UI 展示各乘区分解图

#### Phase 2: LRU 缓存机制

**新增 `calculator_cache.rs` 模块**：

```rust
pub struct CachedCalculator {
    result_cache: LruCache<CacheKey, CalculatorOutput>,
    cache_hits: u64,
    cache_misses: u64,
}

impl CachedCalculator {
    // 带缓存的计算
    pub fn calculate(&mut self, input: &CalculatorInput) -> Result<CalculatorOutput>;
    
    // 计算预览差异（悬停预览场景）
    pub fn calculate_diff(&mut self, base: &CalculatorInput, preview: &CalculatorInput) 
        -> Result<CalculationDiff>;
}
```

**缓存键设计**：
- 基于装备、技能、机制状态、目标配置生成唯一哈希
- 使用 `DefaultHasher` 进行快速哈希计算
- LRU 策略，默认容量 128

**新增 WASM 入口**：

| 函数 | 用途 |
|------|------|
| `calculate_cached()` | 带缓存的计算，相同输入返回缓存结果 |
| `calculate_diff()` | 计算两个配置的差异，返回 DPS/EHP diff |
| `get_cache_stats()` | 获取缓存统计（命中率等） |
| `clear_cache()` | 清空缓存 |

**性能收益**：
- 悬停预览场景：相同配置直接返回缓存，响应时间 < 1ms
- 典型命中率：60-80%（根据使用模式）

#### 测试结果

```
✅ 52/52 测试通过
  - test_cache_hit ✓
  - test_cache_key_different_skill_level ✓
  - test_calculate_diff ✓
  - test_cache_stats ✓
  - test_cache_clear ✓
```

#### 设计决策

1. **为什么使用 `thread_local!` 维护全局缓存？**
   - WASM 是单线程环境，无需考虑线程安全
   - 避免每次调用都创建新缓存实例

2. **为什么缓存容量设为 128？**
   - 平衡内存占用和命中率
   - 典型场景（悬停预览）只需少量缓存条目

3. **为什么不缓存中间 StatPool？**
   - 简化实现，降低复杂度
   - 完整计算已足够快（< 5ms）
   - 后续可根据性能分析按需优化

### 2025-12-12: 乘区纠错与结算顺序调整

#### 处理事项
- **积聚独立乘区**：`mod.more.dmg.spell` 作为独立 More 乘区（聚能祝福每层 +3% 法术伤害），不再与全伤 More 混合。
- **世事无常前置拉伸**：最小/最大伤害拉伸（全类型、物理 min/max）提前到点伤阶段，Inc/More 之前应用，避免后续重复放大。
- **历史标签去重**：转化后历史标签的 More 仅在“历史类型 ≠ 当前类型”时叠乘，修复 Lightning→Cold 转化下冷伤重复吃旧律冷伤 More 的问题。

#### 验证结果
- 单测 `test_chain_lightning_with_supports_and_blessings` 通过，场景结果更新：`hit_damage = 8690.89`，`dps_theoretical = 15509.90`，`rate = 1.78`，`crit = 10% / 1.74x`。
  - 说明：修复前因历史标签重复叠乘冷伤 More，命中伤害偏高；修复后为当前数值。

#### 已知告警
- ts-rs 解析 `#[serde(default = \"...\")]` 的警告仍存在，仅提示，不影响计算。

---

### 2024-12-11: 通用机制系统 (Universal Mechanic System)

#### 需求说明

实现一个可扩展的机制系统，支持：
- **祝福 (Blessing)**: 聚能祝福、坚韧祝福、灵动祝福
- **球类 (Charge)**: 狂乱球、能量球、耐力球
- 未来更多机制的扩展

#### 实现的机制

| 机制 ID | 显示名 | 分类 | 上限 | 每层/点效果 |
|---------|--------|------|------|-------------|
| `focus_blessing` | 聚能祝福 | blessing | 4层 | +4% 全伤害 |
| `tenacity_blessing` | 坚韧祝福 | blessing | 4层 | -4% 受到伤害 |
| `agility_blessing` | 灵动祝福 | blessing | 4层 | +4% 攻击/施法速度, +2% 全伤害 |
| `fighting_will` | 战意 | resource | 100点 | +2% 攻击暴击值, +2% 法术暴击值 |

**战意机制特性**:
- 击败怪物、击中劲敌时获得 1 点战意值
- 基础持续时间 10 秒（时间衰减）
- 效果受 `[战意效果]` 属性影响（如 +X% 战意效果）
- 可通过养成获得额外基础效果

#### 数据库变更

新增 `mechanics_registry` 表：

```sql
CREATE TABLE mechanics_registry (
    id VARCHAR(64) PRIMARY KEY,
    display_name VARCHAR(128) NOT NULL,
    category VARCHAR(32) NOT NULL,           -- blessing, charge, resource
    tag_key VARCHAR(64),                     -- 关联标签
    default_stacks INTEGER DEFAULT 0,        -- 默认层数
    max_stacks INTEGER DEFAULT 4,            -- 初始上限
    base_effect_per_stack JSONB NOT NULL,    -- 每层效果
    ...
);
```

#### Rust 代码变更

**新增模块 `mechanics.rs`**:
```rust
pub struct MechanicsProcessor {
    definitions: HashMap<String, MechanicDefinition>,
    states: HashMap<String, MechanicState>,
}

impl MechanicsProcessor {
    // 计算所有机制的基础效果
    pub fn calculate_base_effects(&self) -> HashMap<String, f64>;
    
    // 处理 .per_xxx 类型的属性
    pub fn calculate_per_stack_value(&self, key: &str, value: f64) -> Option<(String, f64)>;
}
```

**新增类型**:
- `MechanicState`: 机制当前状态（层数、是否激活）
- `MechanicDefinition`: 机制定义（每层效果等）

**修改 `StatAggregator`**:
- 支持 `.per_xxx` 属性键自动识别和计算
- 新增 `apply_mechanic_base_effects()` 方法

#### 属性键命名规范

| 类型 | 格式 | 示例 |
|------|------|------|
| 每层加成 | `{base}.per_{mechanic_id}` | `mod.inc.dmg.cold.per_focus_blessing` |
| 基础效果 | `{attribute}` | `mod.inc.dmg.all`, `speed.attack` |

#### 计算流程

1. 初始化 `MechanicsProcessor`
2. 应用机制基础效果（如聚能祝福 4层 × 4% = 16% 伤害）
3. 处理装备词缀中的 `.per_xxx` 属性
4. 汇总到 StatPool

#### 测试结果

```
✅ 25/25 测试通过
  - test_focus_blessing_base_effect ✓
  - test_fortify_blessing_base_effect ✓
  - test_swift_blessing_base_effect ✓
  - test_multiple_blessings ✓
  - test_per_stack_attribute ✓
```

#### 扩展性

添加新机制只需：
1. 在 `mechanics_registry` 表添加数据
2. 在 `tags_registry` 添加关联标签
3. **无需修改 Rust 代码**

---

### 2024-12-11: 暗金装备属性计算规则

#### 需求说明

暗金装备的属性需要从两部分合并计算：
1. **基底属性**：来自 `items_meta` 表（如手套基底提供 1777 护甲）
2. **暗金词缀属性**：来自 `unique_affixes` 表（如暗金词缀提供 2880-3456 护甲）

计算公式：
```
最终属性 = (基底属性 + 暗金词缀平面值) × (1 + 该装备百分比加成)
```

#### 示例：玛格努斯的旧律

| 来源 | 属性 | 数值 |
|------|------|------|
| 基底 (gloves_old_kings_rerebraces) | 护甲 | 1777 (固定) |
| 暗金词缀 | 护甲 | 2880-3456 (随机) |
| **总计** | **护甲** | **4657-5233** |

#### 代码变更

**`types.rs` - ItemData 结构体**
```rust
pub struct ItemData {
    // 新增：基底固有属性（来自 items_meta）
    pub base_implicit_stats: HashMap<String, f64>,
    // 暗金词缀属性
    pub implicit_stats: HashMap<String, f64>,
    // 新增：是否为暗金装备
    pub is_unique: bool,
    ...
}
```

**`stats.rs` - StatAggregator**
```rust
// 新增：每件装备的局部属性池
pub struct ItemLocalStats {
    pub base_armor: f64,      // 基底护甲
    pub affix_armor: f64,     // 词缀护甲
    pub armor_percent: f64,   // 该装备护甲%
    // ... 护盾、闪避同理
}
```

#### 计算逻辑

1. 遍历每件装备，分别收集基底属性和词缀属性
2. 识别局部百分比加成（如 `mod.inc.def.armor.local`）
3. 合并计算：`(base + affix) * (1 + percent)`
4. 汇总到全局属性池

#### 新增测试用例

- `test_unique_item_armor_calculation`：验证基底+词缀护甲合并
- `test_unique_item_armor_with_percent`：验证带百分比加成的计算
- `test_unique_item_es_calculation`：验证护盾计算

---

### 2025-12-10: 真实技能数据导入

#### 数据来源
从 `meta-json/active_skills_with_details.json` 解析并导入了 6 个真实主动技能的完整数据。

#### 导入的技能

| 技能 ID | 显示名 | 伤害类型 | 施法时间 | 特殊效果 |
|---------|--------|----------|----------|----------|
| `skill_thunderbolt_overload` | 超载雷球 | 闪电 | 0.65s | 100%物理转闪电, 分裂机制 |
| `skill_fire_burst` | 爆炎术 | 火焰 | 0.8s | 范围火焰伤害 |
| `skill_shackles_of_malice` | 恶意枷锁 | 腐蚀 | 1.0s | 双段伤害(锁链+爆炸), 诅咒加成 |
| `skill_chain_lightning` | 闪电链 | 闪电 | 0.65s | +2 弹射次数 |
| `skill_ice_lances` | 冰锥术 | 冰冷 | 0.65s | +1 弹射, 霰弹衰减64% |
| `skill_ring_of_ice` | 冰环术 | 冰冷 | 0.8s | 20%几率重复触发 |

#### 数据处理

1. **伤害文本解析**：从 `"造成 X-Y 法术火焰伤害"` 格式提取 min/max 值和伤害类型
2. **伤害倍率转换**：`"163%"` → `1.63` (小数存储)
3. **特殊效果映射**：提取连锁次数、分裂数量、衰减系数等存入 `extra_effects` JSONB
4. **等级数据**：每技能导入完整 1-20 级数据 (共 120 行)

#### 清理的测试数据

移除了原有的占位测试技能：
- ❌ `skill_fireball` (火球术)
- ❌ `skill_ice_spear` (冰矛)
- ❌ `skill_lightning_strike` (闪电打击)
- ❌ `skill_heavy_strike` (重击)
- ❌ `skill_cyclone` (旋风斩)

保留了辅助技能（占位）：
- ✅ `support_frenzy` (狂雷)
- ✅ `support_empower` (增幅)
- ✅ `support_faster_casting` (快速施法)

---

### 2025-12-10: 技能等级成长系统

#### 需求来源
用户提供了闪电链技能的完整等级数据（1-20级），要求系统支持：
1. 每个技能等级有独立的伤害倍率（effectiveness）和基础伤害
2. 21-30级：效用和基础点伤不再提升，每级额外 +10% 伤害（叠乘）
3. 31级及以上：每级额外 +8% 伤害（叠乘）

#### 数据库变更

新增两张表：

| 表名 | 用途 | 关键字段 |
|------|------|---------|
| `skill_level_data` | 技能等级成长表 | skill_id, level, effectiveness, base_damage, extra_effects |
| `skill_scaling_rules` | 缩放规则表 | skill_id, level_range_start/end, damage_multiplier_per_level |

#### 闪电链数据示例

```sql
-- 1-20级详细数据
skill_level_data:
  level  1: effectiveness=163%, dmg=1-23,   chain_count=2
  level 10: effectiveness=169%, dmg=9-168,  chain_count=2
  level 20: effectiveness=177%, dmg=95-1811, chain_count=2

-- 21级及以上使用缩放规则
skill_scaling_rules:
  21-30级: multiplier=1.10 (每级 +10%)
  31+级:   multiplier=1.08 (每级 +8%)
```

#### Rust 类型扩展

```rust
// 新增结构
pub struct SkillLevelData {
    pub effectiveness: f64,
    pub base_damage: HashMap<String, f64>,
    pub extra_effects: HashMap<String, f64>,
    ...
}

pub struct SkillScalingRule {
    pub level_start: u32,
    pub level_end: Option<u32>,
    pub multiplier_per_level: f64,
}
```

#### 计算逻辑

```rust
fn calculate_level_scaling(level: u32, rules: &[SkillScalingRule]) -> f64 {
    // 1-20级: 无额外缩放
    // 21-30级: (1.10)^(level-20)
    // 31+级: (1.10)^10 * (1.08)^(level-30)
}
```

#### 核心架构决策

1. **三层分离架构**
   - Agent A: Supabase (PostgreSQL) - 数据存储
   - Agent B: Rust/WASM - 纯函数计算
   - Agent C: Next.js - UI 展示 (暂缓)

2. **契约驱动开发**
   - 数据库层通过 `database.types.ts` 导出类型
   - 计算引擎通过 `ts-rs` 导出 TypeScript 绑定
   - 各层通过类型契约解耦

---

### Agent A: 数据库层实现细节

#### 创建的表结构

| 表名 | 用途 | 关键字段 |
|------|------|---------|
| `tags_registry` | 标签注册表 | tag_key, category, parents[], display_name |
| `attributes_meta` | 属性元数据 | attr_key, value_type, is_local, requirements[] |
| `items_meta` | 装备基底 | base_type, slot, is_two_handed, implicit_stats |
| `affixes` | 打造词缀 | affix_group, tier, min_val, max_val, stats |
| `unique_items` | 传奇装备 | id, base_type, slot, is_limited |
| `unique_affixes` | 传奇词缀 | item_id, variant_type, stats |
| `skills` | 技能数据 | skill_type, effectiveness, growth_table |
| `support_skill_modifiers` | 辅助技能加成 | mana_multiplier, injected_tags |
| `hero_traits` | 英雄特性 (占位) | hero_class, trait_type, stats |
| `hero_memories` | 英雄追忆 (占位) | slot, tier, special_effect |
| `pacts` | 石板 (占位) | pact_type, stats |
| `conversion_rules` | 转化 DAG | from_type, to_type, priority |
| `target_configs` | 目标预设 | resistances, generic_dr, armor |

#### 命名空间规范

采用 `dot.notation` 全小写格式：

```
dmg.phys.min      # 物理伤害下限
mod.inc.dmg.fire  # 火焰伤害增加 (Increased)
mod.more.dmg.all  # 总伤害提高 (More)
conv.phys_to_fire # 物理转火焰
extra.phys_as_fire # 物理额外获得火焰
```

**重要约定**: 所有百分比存储为小数 (0.15 = 15%)

#### 设计决策记录

1. **为什么使用 JSONB 存储 stats?**
   - 灵活性：词缀/技能属性组合多变
   - 性能：PostgreSQL JSONB 索引支持良好
   - 缺点：类型安全需要在应用层保证

2. **为什么 unique_affixes 有 variant_type?**
   - 支持侵蚀 (Corrupted) 变体
   - 同一传奇装备的词缀可以有不同版本

3. **hero_traits 和 hero_memories 为何是占位?**
   - 游戏机制复杂，需要更多游戏数据
   - 当前优先实现核心计算流程

---

### Agent B: 计算引擎实现细节

#### 模块结构

```
tli-core/src/
├── lib.rs       # WASM 入口，导出 calculate() 函数
├── types.rs     # 核心类型 (CalculatorInput/Output)
├── tags.rs      # 标签系统 (Interning + BitSet)
├── stats.rs     # 属性聚合器
├── conversion.rs # 伤害转化引擎
├── pipeline.rs  # 完整计算管线
└── utils.rs     # 工具函数
```

#### 核心算法实现

##### 1. 标签整数化 (Tag Interning)

**问题**: WASM 中字符串比较开销大
**解决**: 预加载标签注册表，建立 `HashMap<String, u32>` 映射

```rust
// 运行时所有标签操作使用 u32
let fire_id = registry.get_id("Tag_Fire"); // -> 21
let is_fire = tag_set.contains(21);
```

##### 2. 继承展开 (Inheritance Expansion)

**问题**: `Tag_Fire` 应该自动匹配 `Tag_Elemental` 和 `Tag_Damage` 的增伤
**解决**: 预计算每个标签的完整祖先集

```rust
// Tag_Fire(21) 展开为 [21, 20, 1]
// 21=Fire, 20=Elemental, 1=Damage
let expanded = registry.get_expanded_set(21);
```

##### 3. Tag Retention (标签记忆)

**核心机制**: 伤害转化后保留历史标签，可同时享受多种增伤

```rust
// 100 物理 → 50% 转火焰
// 结果:
//   50 物理 (tags: [Physical])
//   50 火焰 (tags: [Physical, Fire])  <- 关键！保留了 Physical
// 
// 应用增伤:
//   物理部分: 50 * (1 + phys_inc)
//   火焰部分: 50 * (1 + phys_inc) * (1 + fire_inc)  <- 两个都生效
```

**实现方式**: `DamageWithTags` 结构体包含 `history_tags: FixedBitSet`

##### 4. Inc/More 修正系统

**Inc (Increased)**: 同类累加
```rust
total_inc = inc_phys + inc_elemental + inc_all;
damage *= (1.0 + total_inc);
```

**More (Multiplied)**: 按 bucket 分组后相乘
```rust
// bucket 0: skill more
// bucket 100+: support skill more (每个辅助独立 bucket)
damage *= more_bucket_0 * more_bucket_100 * more_bucket_101;
```

**设计原因**: 辅助技能的 More 应该独立相乘，而非累加

##### 5. 计算管线 (Pipeline)

8 阶段顺序执行：

```
1. Sanitization     - 装备槽位冲突处理 (双手武器互斥)
2. Stat Aggregation - 属性池聚合
3. Base Calculation - 基础伤害计算
4. Extra & Convert  - 额外获得 → 转化 (DAG 顺序)
5. Modification     - Inc/More 应用
6. Speed Layer      - 攻速/施法速度
7. Crit & Luck      - 暴击计算
8. Mitigation       - 命中、减伤、输出
```

#### 遇到的问题与解决

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 转化顺序错误 | 未按 DAG 执行 | 定义优先级: Phys→Lightning→Cold→Fire→Chaos |
| Local 属性计算错误 | 武器属性应先于全局计算 | 分离 `local_pool` 和 `global_pool` |
| More 重复计算 | 同 bucket 内应累加而非相乘 | 引入 `bucket_id` 分组机制 |
| 标签匹配性能差 | 字符串比较 | 整数化 + BitSet 集合运算 |

---

### TypeScript 绑定

使用 `ts-rs` crate 自动生成类型定义，确保前后端类型同步。

关键类型：
- `CalculatorInput`: 计算器输入
- `CalculatorOutput`: 计算结果
- `ItemData` / `SkillData`: 装备/技能数据
- `DamageBreakdown`: 伤害构成明细

---

## 待办事项 (TODO)

### 高优先级

- [ ] 补充更多技能数据 (从游戏中提取)
- [ ] 实现 DOT (持续伤害) 计算
- [x] 实现 Lucky 机制 (取两次掷骰最高值) ✅ v0.3.0
- [ ] 完善 EHP 计算公式

### 中优先级

- [x] 从数据库/JSON 动态加载标签注册表 ✅ P0 完成
- [ ] 支持多目标 DPS 计算
- [ ] 实现 CD 恢复速度对 DPS 的影响
- [x] 添加更多单元测试 ✅ 69 tests

### 低优先级

- [ ] 性能优化 (SIMD, 并行计算)
- [x] 支持导出计算过程详细日志 ✅ P3 完成 (zone_sources)
- [ ] 考虑 WebWorker 集成方案

### 已完成 (POB2 对标优化)

- [x] 统一 ModifierStore 抽象 (P1)
- [x] 可扩展条件 AST (P1)
- [x] 缓存中间层 PreparedContext (P2)
- [x] 可解释输出增强 (P3)

---

## 技术债务 (Tech Debt)

1. ~~**硬编码的默认标签注册表**~~ ✅ P0 已解决
   - ~~当前 `pipeline.rs` 中 `create_default_registry()` 是硬编码~~
   - 已改为从 `src/data/tags_registry.json` 加载

2. **缺少完整的错误处理**
   - 部分 `unwrap()` 调用可能 panic
   - 应该返回 `Result` 类型

3. ~~**测试覆盖不足**~~ ✅ 已改善
   - 当前 69 个测试用例
   - 新增条件 AST、ModDB、缓存等测试

4. **StatPool 与 ModDB 双写**
   - 当前 `StatAggregator` 同时维护两套存储
   - 后续可考虑 StatPool 完全由 ModDB 驱动（视图缓存）

---

## 变更日志

| 日期 | 版本 | 变更内容 |
|------|------|---------|
| 2024-12-09 | v0.1.0 | 初始实现 Agent A + Agent B |
| 2024-12-10 | v0.1.1 | 新增技能等级成长系统，导入6个真实主动技能数据 |
| 2024-12-11 | v0.1.2 | 新增暗金装备属性计算规则：基底属性+暗金词缀合并计算 |
| 2024-12-11 | v0.2.0 | 新增通用机制系统（祝福、球类），支持层数效果计算 |
| 2024-12-11 | v0.3.0 | 借鉴 ZSim 架构：乘区明细输出 + LRU 缓存机制 |
| 2024-12-13 | v0.4.0 | POB2 对标优化：ModifierStore/条件AST/缓存中间层/可解释输出 |

---

### 2024-12-13: POB2 对标优化重构

#### 背景

参考 [POB2 (PathOfBuildingCommunity/PathOfBuilding-PoE2)](https://github.com/PathOfBuildingCommunity/PathOfBuilding-PoE2) 的核心架构进行系统性优化，按收益/风险/改动量分为 P0/P1/P2/P3 四个里程碑。

---

#### P0: 基础正确性与数据驱动 ✅

**目标**：消除计算与明细不一致的风险，实现标签数据化加载。

| 模块 | 改动内容 | 涉及文件 |
|------|---------|---------|
| **StatKey 规范** | 修正 `build_multiplier_breakdown` 中读取 key 与 `StatPool` 内部存储不一致的问题，统一使用去前缀的 key（如 `dmg.all` 而非 `mod.inc.dmg.all`） | `pipeline.rs`, `stats.rs` |
| **CacheKey 扩展** | 新增 `context_flags_hash` 和 `context_values_hash` 字段，确保 `cannot_crit`、`lucky_damage` 等标志影响缓存命中 | `calculator_cache.rs` |
| **TagRegistry 数据化** | 新建 `src/data/tags_registry.json` 配置文件（36 个标签定义），使用 `include_str!` 编译时内嵌，回退机制保证健壮性 | `pipeline.rs`, `tags.rs` |

---

#### P1: ModifierStore 抽象与条件系统 ✅

**目标**：对标 POB2 的 ModStore/ModDB/ModList 架构，引入统一的修正存储与条件评估机制。

| 模块 | 改动内容 | 涉及文件 |
|------|---------|---------|
| **modifiers.rs** (新增) | 定义 `Modifier`、`ModifierKind`(Base/Inc/More/Flag/Override)、`ModifierScope`、`PerStatConfig` | `modifiers.rs` |
| **ModDB/ModList** | 按 key 分桶的 HashMap 存储（O(1) 查询），提供 `sum_base/inc`、`product_more`、`has_flag`、`get_override` 等统一接口 | `modifiers.rs` |
| **StatAggregator 迁移** | `finalize()` 返回 `(StatPool, ModDB)` 元组，聚合过程中同时向两者写入，记录详细来源（如 `equip_legend_116:implicit`） | `stats.rs` |
| **condition_ast.rs** (新增) | 可扩展条件 AST：`Flag`、`Compare`、`HasTag`、`MechanicActive`、`MechanicStacks`、`PerStat`、`And/Or/Not` | `condition_ast.rs` |
| **条件评估** | `ModifierStore` 新增 `*_with_ctx()` 系列方法，支持带 `EvalContext` 的条件过滤和 PerStat 计算 | `modifiers.rs` |

**条件表达式示例**：
```rust
// 支持的格式
"is_moving == true && life_percent <= 0.35"
"has_tag(\"Tag_Spell\")"
"mechanic_stacks(\"fighting_will\") >= 50"
"per_stat(\"dexterity\", 10)"  // 每 10 点敏捷
```

---

#### P2: 缓存中间层与增量计算 ✅

**目标**：对标 POB2 的"缓存不仅是最终值"，复用中间结构优化悬停预览。

| 模块 | 改动内容 | 涉及文件 |
|------|---------|---------|
| **PreparedContext** (新增) | 缓存中间计算结果：`stat_pool`、`mod_db`、`base_damages`、`conversion_rules`、`extra_as_rules`、`skill_snapshot` | `pipeline.rs` |
| **prepare_context()** | 准备阶段函数，执行聚合并返回可复用的 `PreparedContext` | `pipeline.rs` |
| **calculate_from_prepared()** | 从 `PreparedContext` 计算最终结果，跳过重复聚合 | `pipeline.rs` |
| **context_cache** | `CachedCalculator` 新增 LRU 上下文缓存（容量 = 结果缓存 / 2） | `calculator_cache.rs` |
| **get_or_prepare_context()** | 获取或计算 `PreparedContext`，带缓存命中统计 | `calculator_cache.rs` |
| **calculate_diff_incremental()** | 增量计算预览差异（复用 base 的 PreparedContext） | `calculator_cache.rs` |
| **ExtendedCacheStats** | 扩展缓存统计，包含结果缓存和上下文缓存的分别统计 | `calculator_cache.rs` |

---

#### P3: 可解释输出增强 ✅

**目标**：对标 PoB Calculations tab，为每个乘区补齐详细来源。

| 模块 | 改动内容 | 涉及文件 |
|------|---------|---------|
| **build_damage_breakdown** | 新增 `mod_db: Option<&ModDB>` 参数 | `pipeline.rs` |
| **build_multiplier_breakdown** | 使用 `ModDB.get_sources()` 获取详细来源，Inc/More 乘区显示具体来源（装备名:词缀名） | `pipeline.rs` |
| **ZoneSource 增强** | 来源字符串格式：`"{source} ({stat_type})"` | `pipeline.rs` |

**示例输出**：
```json
{
  "zone_sources": {
    "increased": [
      {"source": "equip_legend_116:implicit (火焰增伤)", "value": 0.25, "stat_key": "dmg.fire"}
    ],
    "more": [
      {"source": "support:灵能乍泄 (全伤害提高)", "value": 1.45, "stat_key": "dmg.all"}
    ]
  }
}
```

---

#### 测试结果

```
test result: ok. 69 passed; 0 failed; 0 ignored
```

新增测试用例：
- `test_prepared_context_cache`: 验证 PreparedContext 缓存命中
- `test_extended_cache_stats`: 验证扩展缓存统计
- `test_mod_db_with_condition`: 验证带条件的 ModDB 查询
- `test_mod_db_with_per_stat`: 验证 PerStat 计算
- `test_mod_db_with_mechanic_condition`: 验证机制条件评估
- 14 个条件 AST 解析/评估测试

---

#### 新增文件清单

| 文件 | 用途 |
|------|------|
| `tli-core/src/modifiers.rs` | ModifierStore 抽象（ModDB/ModList） |
| `tli-core/src/condition_ast.rs` | 可扩展条件 AST 解析与评估 |
| `tli-core/src/data/tags_registry.json` | 标签定义数据文件（36 个标签） |

---

#### 架构收益

1. **扩展性**：新增属性/条件只需修改数据，无需改代码
2. **可解释性**：UI 可展示"某项 DPS 来自哪些装备/技能"
3. **性能**：悬停预览场景通过 PreparedContext 缓存减少约 50% 聚合开销
4. **一致性**：计算逻辑与明细输出使用相同数据源（ModDB）

---

## 参考资料

- [开发规划 V2.6](./火炬之光：无限%20BD%20决策辅助系统%20-%20开发规划%20(V2.6).md)
- [Maxroll D4 Planner](https://maxroll.gg/d4/planner) - UI 参考
- [Path of Exile Wiki - Damage Conversion](https://pathofexile.fandom.com/wiki/Damage_conversion) - 转化机制参考

---

*本文档由 AI Agent 生成并持续维护*

