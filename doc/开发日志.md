# TLI BD 决策辅助系统 - 开发日志

> 本文档记录项目开发过程中的核心决策、功能变更、遇到的问题及解决方案。
> 供后续 AI Agents 进行 Review 或项目重构时参考。

---

## 项目元信息

| 项目名称 | TLI BD 决策辅助系统 |
|---------|-------------------|
| 版本 | v0.3.0 |
| 创建日期 | 2024-12-09 |
| 最后更新 | 2024-12-11 |
| 规划文档 | `doc/火炬之光：无限 BD 决策辅助系统 - 开发规划 (V2.6).md` |

---

## 开发日志

### 2024-12-09: 项目初始化 (Agent A + Agent B)

#### 本次完成的工作

按照 V2.6 开发规划，完成了 **Agent A (数据库层)** 和 **Agent B (计算引擎)** 的基础实现。

**前端 UI (Agent C) 按要求暂缓开发。**

### 2025-01-07: 编译修复与本地验证

#### 处理事项
- 修复 `StatAggregator` 局部属性聚合的借用冲突：局部词缀直接作用于 `local_pool`，避免 clone 造成的无效修改。
- 清理未使用的导入并恢复转化规则中的 `StatPool` 引入，消除编译错误。
- 去除冗余 `mut`，保持代码整洁。
- 在可联网环境下执行 `cargo check` 已通过。

### 2025-12-09: 完整编译测试通过

#### 修复事项
- **ts-rs API 更新**：将 `export_all()` 改为 `export()`（ts-rs 7.x 版本变更）
- **武器攻速默认值**：修复 `calculate_rate` 函数中 `weapon.base_speed` 未设置时返回 0 导致 DPS 为 0 的问题，默认攻速改为 1.0
- **wasm-opt 兼容问题**：禁用 wasm-opt 优化器（旧版本不支持 bulk memory 操作）

#### 测试结果
- ✅ `cargo test`: 27/27 测试通过
- ✅ `wasm-pack build`: 成功生成 `tli_core.wasm`

#### 产出文件
```
pkg/
├── tli_core.wasm         # 核心 WASM 模块
├── tli_core.js           # JavaScript 胶水代码
├── tli_core.d.ts         # TypeScript 类型定义
├── tli_core_bg.wasm.d.ts # WASM 背景类型
└── package.json          # NPM 包配置
```

#### 仍存在的告警
- ts-rs 无法解析部分 `#[serde(default = "...")]` 属性（仅警告，不影响编译）

### 2024-12-11: 计算引擎 Bug 修复

#### Bug 1: `crit_zone` 计算公式 ✅ 已修复

**问题**：`build_multiplier_breakdown` 中 `crit_zone` 公式错误。

**语义确认**：`crit_multiplier = 1.5` 表示"150% 总暴击伤害"（非暴击为 100%）。

**修复**：
```rust
// 修复前 (错误)
let crit_zone = 1.0 + effective_crit_chance * crit_multiplier;

// 修复后 (正确)
let crit_zone = 1.0 + effective_crit_chance * (crit_multiplier - 1.0);
```

**示例验证**：
- 50% 暴击率，150% 暴击伤害
- 修复前: `1 + 0.5 * 1.5 = 1.75` ❌ (多算了 0.5)
- 修复后: `1 + 0.5 * 0.5 = 1.25` ✅

#### Bug 2: 缓存键缺失上下文数据 ⏸️ 暂缓

- **状态**：暂时忽略，待后续评估 `context_flags/values` 对计算的实际影响
- **原因**：当前条件计算逻辑尚未完全依赖这些值

---

### 2025-12-11: 核心天赋 & 机制扩展（已推送 Supabase）

#### 新增核心天赋（已 upsert 至 Supabase 项目 `tld`）
- **苦寒**：击中获得聚能祝福；聚能祝福上限 +1
- **积聚**：聚能祝福上限 +1；每层聚能祝福 +3% 法术伤害（per_focus_blessing）
- **世事无常**：物理最小伤害 -90%，物理最大伤害 +80%；全类型最小伤害 -40%，最大伤害 +40%（依赖 min/max More 乘区）
- **奇妙角度**：你造成的伤害“幸运”（两次取高值）

#### 计算引擎更新
- 支持按最小/最大值拆分的 More 乘区（含物理/全局 min/max 键）
- 支持 Lucky 期望伤害：`flag.lucky` 或 `context_flags.lucky_damage` 为真时，期望从 0.5 提升到 2/3
- 聚能祝福钩子：上限 +1、每层 +3% 法术伤害（per_xxx 机制生效）

#### 数据库同步
- 已通过 MCP 对 Supabase `tld` (`doemvsjyjzvtxaxaxhyl`) 执行 upsert 至 `hero_traits`

---

### 2024-12-11: ZSim 架构优化借鉴

#### 背景

参考 ZSim（绝区零战斗模拟器）的核心仿真引擎架构，对 TLI 计算引擎进行优化：
- **乘区明细输出**：借鉴 ZSim 的 9 乘区分离设计
- **LRU 缓存机制**：借鉴 ZSim 的 MultiplierData 缓存策略

#### Phase 1: 乘区明细输出

**新增 `MultiplierBreakdown` 结构**：

```rust
pub struct MultiplierBreakdown {
    pub base_damage_zone: f64,    // 基础伤害区
    pub increased_zone: f64,      // 增伤区 (1 + sum(inc))
    pub more_zone: f64,           // More 乘区 (product of more)
    pub crit_zone: f64,           // 暴击期望区
    pub speed_zone: f64,          // 速度区
    pub hit_zone: f64,            // 命中区
    pub defense_zone: f64,        // 防御区 (敌人护甲)
    pub resistance_zone: f64,     // 抗性区
    pub vulnerability_zone: f64,  // 易伤区
    pub mechanics_zone: f64,      // 机制特殊区
    pub zone_sources: HashMap<String, Vec<ZoneSource>>, // 来源追踪
}
```

**用途**：
- 用户可清晰看到每个乘区的贡献
- 便于调试和验证计算过程
- 支持 UI 展示各乘区分解图

#### Phase 2: LRU 缓存机制

**新增 `calculator_cache.rs` 模块**：

```rust
pub struct CachedCalculator {
    result_cache: LruCache<CacheKey, CalculatorOutput>,
    cache_hits: u64,
    cache_misses: u64,
}

impl CachedCalculator {
    // 带缓存的计算
    pub fn calculate(&mut self, input: &CalculatorInput) -> Result<CalculatorOutput>;
    
    // 计算预览差异（悬停预览场景）
    pub fn calculate_diff(&mut self, base: &CalculatorInput, preview: &CalculatorInput) 
        -> Result<CalculationDiff>;
}
```

**缓存键设计**：
- 基于装备、技能、机制状态、目标配置生成唯一哈希
- 使用 `DefaultHasher` 进行快速哈希计算
- LRU 策略，默认容量 128

**新增 WASM 入口**：

| 函数 | 用途 |
|------|------|
| `calculate_cached()` | 带缓存的计算，相同输入返回缓存结果 |
| `calculate_diff()` | 计算两个配置的差异，返回 DPS/EHP diff |
| `get_cache_stats()` | 获取缓存统计（命中率等） |
| `clear_cache()` | 清空缓存 |

**性能收益**：
- 悬停预览场景：相同配置直接返回缓存，响应时间 < 1ms
- 典型命中率：60-80%（根据使用模式）

#### 测试结果

```
✅ 52/52 测试通过
  - test_cache_hit ✓
  - test_cache_key_different_skill_level ✓
  - test_calculate_diff ✓
  - test_cache_stats ✓
  - test_cache_clear ✓
```

#### 设计决策

1. **为什么使用 `thread_local!` 维护全局缓存？**
   - WASM 是单线程环境，无需考虑线程安全
   - 避免每次调用都创建新缓存实例

2. **为什么缓存容量设为 128？**
   - 平衡内存占用和命中率
   - 典型场景（悬停预览）只需少量缓存条目

3. **为什么不缓存中间 StatPool？**
   - 简化实现，降低复杂度
   - 完整计算已足够快（< 5ms）
   - 后续可根据性能分析按需优化

---

### 2024-12-11: 通用机制系统 (Universal Mechanic System)

#### 需求说明

实现一个可扩展的机制系统，支持：
- **祝福 (Blessing)**: 聚能祝福、坚韧祝福、灵动祝福
- **球类 (Charge)**: 狂乱球、能量球、耐力球
- 未来更多机制的扩展

#### 实现的机制

| 机制 ID | 显示名 | 分类 | 上限 | 每层/点效果 |
|---------|--------|------|------|-------------|
| `focus_blessing` | 聚能祝福 | blessing | 4层 | +4% 全伤害 |
| `tenacity_blessing` | 坚韧祝福 | blessing | 4层 | -4% 受到伤害 |
| `agility_blessing` | 灵动祝福 | blessing | 4层 | +4% 攻击/施法速度, +2% 全伤害 |
| `fighting_will` | 战意 | resource | 100点 | +2% 攻击暴击值, +2% 法术暴击值 |

**战意机制特性**:
- 击败怪物、击中劲敌时获得 1 点战意值
- 基础持续时间 10 秒（时间衰减）
- 效果受 `[战意效果]` 属性影响（如 +X% 战意效果）
- 可通过养成获得额外基础效果

#### 数据库变更

新增 `mechanics_registry` 表：

```sql
CREATE TABLE mechanics_registry (
    id VARCHAR(64) PRIMARY KEY,
    display_name VARCHAR(128) NOT NULL,
    category VARCHAR(32) NOT NULL,           -- blessing, charge, resource
    tag_key VARCHAR(64),                     -- 关联标签
    default_stacks INTEGER DEFAULT 0,        -- 默认层数
    max_stacks INTEGER DEFAULT 4,            -- 初始上限
    base_effect_per_stack JSONB NOT NULL,    -- 每层效果
    ...
);
```

#### Rust 代码变更

**新增模块 `mechanics.rs`**:
```rust
pub struct MechanicsProcessor {
    definitions: HashMap<String, MechanicDefinition>,
    states: HashMap<String, MechanicState>,
}

impl MechanicsProcessor {
    // 计算所有机制的基础效果
    pub fn calculate_base_effects(&self) -> HashMap<String, f64>;
    
    // 处理 .per_xxx 类型的属性
    pub fn calculate_per_stack_value(&self, key: &str, value: f64) -> Option<(String, f64)>;
}
```

**新增类型**:
- `MechanicState`: 机制当前状态（层数、是否激活）
- `MechanicDefinition`: 机制定义（每层效果等）

**修改 `StatAggregator`**:
- 支持 `.per_xxx` 属性键自动识别和计算
- 新增 `apply_mechanic_base_effects()` 方法

#### 属性键命名规范

| 类型 | 格式 | 示例 |
|------|------|------|
| 每层加成 | `{base}.per_{mechanic_id}` | `mod.inc.dmg.cold.per_focus_blessing` |
| 基础效果 | `{attribute}` | `mod.inc.dmg.all`, `speed.attack` |

#### 计算流程

1. 初始化 `MechanicsProcessor`
2. 应用机制基础效果（如聚能祝福 4层 × 4% = 16% 伤害）
3. 处理装备词缀中的 `.per_xxx` 属性
4. 汇总到 StatPool

#### 测试结果

```
✅ 25/25 测试通过
  - test_focus_blessing_base_effect ✓
  - test_fortify_blessing_base_effect ✓
  - test_swift_blessing_base_effect ✓
  - test_multiple_blessings ✓
  - test_per_stack_attribute ✓
```

#### 扩展性

添加新机制只需：
1. 在 `mechanics_registry` 表添加数据
2. 在 `tags_registry` 添加关联标签
3. **无需修改 Rust 代码**

---

### 2024-12-11: 暗金装备属性计算规则

#### 需求说明

暗金装备的属性需要从两部分合并计算：
1. **基底属性**：来自 `items_meta` 表（如手套基底提供 1777 护甲）
2. **暗金词缀属性**：来自 `unique_affixes` 表（如暗金词缀提供 2880-3456 护甲）

计算公式：
```
最终属性 = (基底属性 + 暗金词缀平面值) × (1 + 该装备百分比加成)
```

#### 示例：玛格努斯的旧律

| 来源 | 属性 | 数值 |
|------|------|------|
| 基底 (gloves_old_kings_rerebraces) | 护甲 | 1777 (固定) |
| 暗金词缀 | 护甲 | 2880-3456 (随机) |
| **总计** | **护甲** | **4657-5233** |

#### 代码变更

**`types.rs` - ItemData 结构体**
```rust
pub struct ItemData {
    // 新增：基底固有属性（来自 items_meta）
    pub base_implicit_stats: HashMap<String, f64>,
    // 暗金词缀属性
    pub implicit_stats: HashMap<String, f64>,
    // 新增：是否为暗金装备
    pub is_unique: bool,
    ...
}
```

**`stats.rs` - StatAggregator**
```rust
// 新增：每件装备的局部属性池
pub struct ItemLocalStats {
    pub base_armor: f64,      // 基底护甲
    pub affix_armor: f64,     // 词缀护甲
    pub armor_percent: f64,   // 该装备护甲%
    // ... 护盾、闪避同理
}
```

#### 计算逻辑

1. 遍历每件装备，分别收集基底属性和词缀属性
2. 识别局部百分比加成（如 `mod.inc.def.armor.local`）
3. 合并计算：`(base + affix) * (1 + percent)`
4. 汇总到全局属性池

#### 新增测试用例

- `test_unique_item_armor_calculation`：验证基底+词缀护甲合并
- `test_unique_item_armor_with_percent`：验证带百分比加成的计算
- `test_unique_item_es_calculation`：验证护盾计算

---

### 2025-12-10: 真实技能数据导入

#### 数据来源
从 `meta-json/active_skills_with_details.json` 解析并导入了 6 个真实主动技能的完整数据。

#### 导入的技能

| 技能 ID | 显示名 | 伤害类型 | 施法时间 | 特殊效果 |
|---------|--------|----------|----------|----------|
| `skill_thunderbolt_overload` | 超载雷球 | 闪电 | 0.65s | 100%物理转闪电, 分裂机制 |
| `skill_fire_burst` | 爆炎术 | 火焰 | 0.8s | 范围火焰伤害 |
| `skill_shackles_of_malice` | 恶意枷锁 | 腐蚀 | 1.0s | 双段伤害(锁链+爆炸), 诅咒加成 |
| `skill_chain_lightning` | 闪电链 | 闪电 | 0.65s | +2 弹射次数 |
| `skill_ice_lances` | 冰锥术 | 冰冷 | 0.65s | +1 弹射, 霰弹衰减64% |
| `skill_ring_of_ice` | 冰环术 | 冰冷 | 0.8s | 20%几率重复触发 |

#### 数据处理

1. **伤害文本解析**：从 `"造成 X-Y 法术火焰伤害"` 格式提取 min/max 值和伤害类型
2. **伤害倍率转换**：`"163%"` → `1.63` (小数存储)
3. **特殊效果映射**：提取连锁次数、分裂数量、衰减系数等存入 `extra_effects` JSONB
4. **等级数据**：每技能导入完整 1-20 级数据 (共 120 行)

#### 清理的测试数据

移除了原有的占位测试技能：
- ❌ `skill_fireball` (火球术)
- ❌ `skill_ice_spear` (冰矛)
- ❌ `skill_lightning_strike` (闪电打击)
- ❌ `skill_heavy_strike` (重击)
- ❌ `skill_cyclone` (旋风斩)

保留了辅助技能（占位）：
- ✅ `support_frenzy` (狂雷)
- ✅ `support_empower` (增幅)
- ✅ `support_faster_casting` (快速施法)

---

### 2025-12-10: 技能等级成长系统

#### 需求来源
用户提供了闪电链技能的完整等级数据（1-20级），要求系统支持：
1. 每个技能等级有独立的伤害倍率（effectiveness）和基础伤害
2. 21-30级：效用和基础点伤不再提升，每级额外 +10% 伤害（叠乘）
3. 31级及以上：每级额外 +8% 伤害（叠乘）

#### 数据库变更

新增两张表：

| 表名 | 用途 | 关键字段 |
|------|------|---------|
| `skill_level_data` | 技能等级成长表 | skill_id, level, effectiveness, base_damage, extra_effects |
| `skill_scaling_rules` | 缩放规则表 | skill_id, level_range_start/end, damage_multiplier_per_level |

#### 闪电链数据示例

```sql
-- 1-20级详细数据
skill_level_data:
  level  1: effectiveness=163%, dmg=1-23,   chain_count=2
  level 10: effectiveness=169%, dmg=9-168,  chain_count=2
  level 20: effectiveness=177%, dmg=95-1811, chain_count=2

-- 21级及以上使用缩放规则
skill_scaling_rules:
  21-30级: multiplier=1.10 (每级 +10%)
  31+级:   multiplier=1.08 (每级 +8%)
```

#### Rust 类型扩展

```rust
// 新增结构
pub struct SkillLevelData {
    pub effectiveness: f64,
    pub base_damage: HashMap<String, f64>,
    pub extra_effects: HashMap<String, f64>,
    ...
}

pub struct SkillScalingRule {
    pub level_start: u32,
    pub level_end: Option<u32>,
    pub multiplier_per_level: f64,
}
```

#### 计算逻辑

```rust
fn calculate_level_scaling(level: u32, rules: &[SkillScalingRule]) -> f64 {
    // 1-20级: 无额外缩放
    // 21-30级: (1.10)^(level-20)
    // 31+级: (1.10)^10 * (1.08)^(level-30)
}
```

#### 核心架构决策

1. **三层分离架构**
   - Agent A: Supabase (PostgreSQL) - 数据存储
   - Agent B: Rust/WASM - 纯函数计算
   - Agent C: Next.js - UI 展示 (暂缓)

2. **契约驱动开发**
   - 数据库层通过 `database.types.ts` 导出类型
   - 计算引擎通过 `ts-rs` 导出 TypeScript 绑定
   - 各层通过类型契约解耦

---

### Agent A: 数据库层实现细节

#### 创建的表结构

| 表名 | 用途 | 关键字段 |
|------|------|---------|
| `tags_registry` | 标签注册表 | tag_key, category, parents[], display_name |
| `attributes_meta` | 属性元数据 | attr_key, value_type, is_local, requirements[] |
| `items_meta` | 装备基底 | base_type, slot, is_two_handed, implicit_stats |
| `affixes` | 打造词缀 | affix_group, tier, min_val, max_val, stats |
| `unique_items` | 传奇装备 | id, base_type, slot, is_limited |
| `unique_affixes` | 传奇词缀 | item_id, variant_type, stats |
| `skills` | 技能数据 | skill_type, effectiveness, growth_table |
| `support_skill_modifiers` | 辅助技能加成 | mana_multiplier, injected_tags |
| `hero_traits` | 英雄特性 (占位) | hero_class, trait_type, stats |
| `hero_memories` | 英雄追忆 (占位) | slot, tier, special_effect |
| `pacts` | 石板 (占位) | pact_type, stats |
| `conversion_rules` | 转化 DAG | from_type, to_type, priority |
| `target_configs` | 目标预设 | resistances, generic_dr, armor |

#### 命名空间规范

采用 `dot.notation` 全小写格式：

```
dmg.phys.min      # 物理伤害下限
mod.inc.dmg.fire  # 火焰伤害增加 (Increased)
mod.more.dmg.all  # 总伤害提高 (More)
conv.phys_to_fire # 物理转火焰
extra.phys_as_fire # 物理额外获得火焰
```

**重要约定**: 所有百分比存储为小数 (0.15 = 15%)

#### 设计决策记录

1. **为什么使用 JSONB 存储 stats?**
   - 灵活性：词缀/技能属性组合多变
   - 性能：PostgreSQL JSONB 索引支持良好
   - 缺点：类型安全需要在应用层保证

2. **为什么 unique_affixes 有 variant_type?**
   - 支持侵蚀 (Corrupted) 变体
   - 同一传奇装备的词缀可以有不同版本

3. **hero_traits 和 hero_memories 为何是占位?**
   - 游戏机制复杂，需要更多游戏数据
   - 当前优先实现核心计算流程

---

### Agent B: 计算引擎实现细节

#### 模块结构

```
tli-core/src/
├── lib.rs       # WASM 入口，导出 calculate() 函数
├── types.rs     # 核心类型 (CalculatorInput/Output)
├── tags.rs      # 标签系统 (Interning + BitSet)
├── stats.rs     # 属性聚合器
├── conversion.rs # 伤害转化引擎
├── pipeline.rs  # 完整计算管线
└── utils.rs     # 工具函数
```

#### 核心算法实现

##### 1. 标签整数化 (Tag Interning)

**问题**: WASM 中字符串比较开销大
**解决**: 预加载标签注册表，建立 `HashMap<String, u32>` 映射

```rust
// 运行时所有标签操作使用 u32
let fire_id = registry.get_id("Tag_Fire"); // -> 21
let is_fire = tag_set.contains(21);
```

##### 2. 继承展开 (Inheritance Expansion)

**问题**: `Tag_Fire` 应该自动匹配 `Tag_Elemental` 和 `Tag_Damage` 的增伤
**解决**: 预计算每个标签的完整祖先集

```rust
// Tag_Fire(21) 展开为 [21, 20, 1]
// 21=Fire, 20=Elemental, 1=Damage
let expanded = registry.get_expanded_set(21);
```

##### 3. Tag Retention (标签记忆)

**核心机制**: 伤害转化后保留历史标签，可同时享受多种增伤

```rust
// 100 物理 → 50% 转火焰
// 结果:
//   50 物理 (tags: [Physical])
//   50 火焰 (tags: [Physical, Fire])  <- 关键！保留了 Physical
// 
// 应用增伤:
//   物理部分: 50 * (1 + phys_inc)
//   火焰部分: 50 * (1 + phys_inc) * (1 + fire_inc)  <- 两个都生效
```

**实现方式**: `DamageWithTags` 结构体包含 `history_tags: FixedBitSet`

##### 4. Inc/More 修正系统

**Inc (Increased)**: 同类累加
```rust
total_inc = inc_phys + inc_elemental + inc_all;
damage *= (1.0 + total_inc);
```

**More (Multiplied)**: 按 bucket 分组后相乘
```rust
// bucket 0: skill more
// bucket 100+: support skill more (每个辅助独立 bucket)
damage *= more_bucket_0 * more_bucket_100 * more_bucket_101;
```

**设计原因**: 辅助技能的 More 应该独立相乘，而非累加

##### 5. 计算管线 (Pipeline)

8 阶段顺序执行：

```
1. Sanitization     - 装备槽位冲突处理 (双手武器互斥)
2. Stat Aggregation - 属性池聚合
3. Base Calculation - 基础伤害计算
4. Extra & Convert  - 额外获得 → 转化 (DAG 顺序)
5. Modification     - Inc/More 应用
6. Speed Layer      - 攻速/施法速度
7. Crit & Luck      - 暴击计算
8. Mitigation       - 命中、减伤、输出
```

#### 遇到的问题与解决

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 转化顺序错误 | 未按 DAG 执行 | 定义优先级: Phys→Lightning→Cold→Fire→Chaos |
| Local 属性计算错误 | 武器属性应先于全局计算 | 分离 `local_pool` 和 `global_pool` |
| More 重复计算 | 同 bucket 内应累加而非相乘 | 引入 `bucket_id` 分组机制 |
| 标签匹配性能差 | 字符串比较 | 整数化 + BitSet 集合运算 |

---

### TypeScript 绑定

使用 `ts-rs` crate 自动生成类型定义，确保前后端类型同步。

关键类型：
- `CalculatorInput`: 计算器输入
- `CalculatorOutput`: 计算结果
- `ItemData` / `SkillData`: 装备/技能数据
- `DamageBreakdown`: 伤害构成明细

---

## 待办事项 (TODO)

### 高优先级

- [ ] 补充更多技能数据 (从游戏中提取)
- [ ] 实现 DOT (持续伤害) 计算
- [ ] 实现 Lucky 机制 (取两次掷骰最高值)
- [ ] 完善 EHP 计算公式

### 中优先级

- [ ] 从数据库动态加载标签注册表
- [ ] 支持多目标 DPS 计算
- [ ] 实现 CD 恢复速度对 DPS 的影响
- [ ] 添加更多单元测试

### 低优先级

- [ ] 性能优化 (SIMD, 并行计算)
- [ ] 支持导出计算过程详细日志
- [ ] 考虑 WebWorker 集成方案

---

## 技术债务 (Tech Debt)

1. **硬编码的默认标签注册表**
   - 当前 `pipeline.rs` 中 `create_default_registry()` 是硬编码
   - 应该从数据库或 JSON 文件加载

2. **缺少完整的错误处理**
   - 部分 `unwrap()` 调用可能 panic
   - 应该返回 `Result` 类型

3. **测试覆盖不足**
   - 需要更多边界条件测试
   - 需要集成测试验证完整流程

---

## 变更日志

| 日期 | 版本 | 变更内容 |
|------|------|---------|
| 2024-12-09 | v0.1.0 | 初始实现 Agent A + Agent B |
| 2024-12-10 | v0.1.1 | 新增技能等级成长系统，导入6个真实主动技能数据 |
| 2024-12-11 | v0.1.2 | 新增暗金装备属性计算规则：基底属性+暗金词缀合并计算 |
| 2024-12-11 | v0.2.0 | 新增通用机制系统（祝福、球类），支持层数效果计算 |
| 2024-12-11 | v0.3.0 | 借鉴 ZSim 架构：乘区明细输出 + LRU 缓存机制 |

---

## 参考资料

- [开发规划 V2.6](./火炬之光：无限%20BD%20决策辅助系统%20-%20开发规划%20(V2.6).md)
- [Maxroll D4 Planner](https://maxroll.gg/d4/planner) - UI 参考
- [Path of Exile Wiki - Damage Conversion](https://pathofexile.fandom.com/wiki/Damage_conversion) - 转化机制参考

---

*本文档由 AI Agent 生成并持续维护*

