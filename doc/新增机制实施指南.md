# TLI 新增复杂机制实施指南

## 1. 系统架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        新增机制流程                              │
├─────────────────────────────────────────────────────────────────┤
│  Step 1: 数据定义 (Agent A)                                      │
│  ├─ hero_traits / mechanics_registry                            │
│  ├─ unique_items / unique_affixes                               │
│  └─ tags_registry (如需新标签)                                   │
├─────────────────────────────────────────────────────────────────┤
│  Step 2: 引擎扩展 (Agent B)                                      │
│  ├─ condition_ast.rs (新条件类型)                                │
│  ├─ mechanics.rs (机制效果计算)                                  │
│  ├─ modifiers.rs (特殊修正类型)                                  │
│  └─ pipeline.rs (管线阶段扩展)                                   │
├─────────────────────────────────────────────────────────────────┤
│  Step 3: 集成测试                                                │
│  └─ 构造 CalculatorInput 验证计算结果                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 机制复杂度分级

| 级别 | 描述 | 示例 | 需要修改的层级 |
|------|------|------|---------------|
| **L1** | 简单数值加成 | 装备词缀 "+20% 火焰伤害" | 仅数据层 |
| **L2** | 带条件的加成 | "移动时 +30% 伤害" | 数据层 + 条件表达式 |
| **L3** | 机制联动 | "每层聚能祝福 +X%" | 数据层 + mechanics.rs |
| **L4** | 管线修改 | "伤害幸运（取两次高值）" | 数据层 + pipeline.rs |
| **L5** | 新计算范式 | DOT 系统、召唤物 | 全栈改造 |

---

## 3. 通用实施步骤

### Step 1: 需求分解

将机制拆解为以下维度：

```markdown
## 机制需求模板

### 基本信息
- 机制名称: [中文名]
- 机制 ID: [英文标识符]
- 分类: blessing / charge / resource / trait / item_mod

### 触发条件
- 获取方式: [击中/击杀/装备/天赋]
- 激活条件: [always / condition_expr]
- 层数上限: [数字或表达式]

### 效果描述
- 每层/每点效果:
  - [属性键]: [数值] (Inc/More/Base/Flag)
- 联动属性 (per_xxx):
  - 来源装备/天赋: [item_id / trait_id]
  - 效果: [每层 +X% 属性]

### 计算阶段
- 生效时机: [聚合阶段 / Inc阶段 / More阶段 / 点伤阶段]
- 是否影响转化: [是/否]
- 是否参与暴击: [是/否]

### 特殊规则
- [描述任何特殊计算逻辑]
```

---

### Step 2: 数据层定义 (Agent A)

#### 2.1 新增标签（如需）

```sql
-- supabase/seed.sql 或通过 MCP 执行
INSERT INTO tags_registry (tag_key, category, parents, display_name)
VALUES ('Mech_NewMechanic', 'Mechanic', '[]', '新机制标签')
ON CONFLICT (tag_key) DO UPDATE SET display_name = EXCLUDED.display_name;
```

同步更新 JSON：

```json
// tli-core/src/data/tags_registry.json
{
  "Mech_NewMechanic": {
    "id": 300,
    "category": "Mechanic",
    "parents": [],
    "displayName": "新机制"
  }
}
```

#### 2.2 定义机制（天赋/装备）

```sql
-- 核心天赋
INSERT INTO hero_traits (id, display_name, hero_class, trait_type, stats)
VALUES (
  'trait_new_mechanic',
  '新机制天赋',
  'generic',
  'core',
  '{
    "mechanic.new_mechanic.max_stacks": 1,
    "mod.more.dmg.all.per_new_mechanic": 0.05
  }'::jsonb
);

-- 装备词缀
INSERT INTO unique_affixes (item_id, stats, variant_type)
VALUES (
  'equip_legend_xxx',
  '{
    "mod.inc.dmg.fire.per_new_mechanic": 0.10,
    "new_mechanic.duration": 0.20
  }'::jsonb,
  'normal'
);
```

#### 2.3 属性键命名规范

```
# 基础效果
mod.inc.{attribute}                    # Increased (累加)
mod.more.{attribute}                   # More (独立相乘)

# 每层/每点效果
mod.inc.{attribute}.per_{mechanic_id}  # 每层提供 Increased
mod.more.{attribute}.per_{mechanic_id} # 每层提供 More

# 机制控制
mechanic.{mechanic_id}.max_stacks      # 上限修改
{mechanic_id}.duration                 # 持续时间修改
{mechanic_id}.effect                   # 效果倍率修改

# 条件标志
flag.{flag_name}                       # 布尔开关
```

---

### Step 3: 引擎扩展 (Agent B)

#### 3.1 简单联动（L3）—— 仅需数据

如果机制效果完全是 `.per_xxx` 类型，**无需修改 Rust 代码**：

```rust
// mechanics.rs 已支持自动识别
// 只需在数据层正确配置 per_xxx 属性
// StatAggregator.apply_stat() 会自动处理
```

#### 3.2 条件扩展（L2-L3）

如需新增条件类型，修改 `condition_ast.rs`：

```rust
// 新增条件节点类型
pub enum Condition {
    // ... 现有类型 ...
    
    /// 新机制层数检查
    NewMechanicStacks { threshold: u32, op: CompareOp },
}

// 实现解析
fn parse_new_mechanic_stacks(expr: &str) -> Result<Self, String> {
    // "new_mechanic_stacks >= 5"
    // ...
}

// 实现评估
fn evaluate(&self, ctx: &EvalContext) -> bool {
    match self {
        Condition::NewMechanicStacks { threshold, op } => {
            let stacks = ctx.mechanic_stacks
                .get("new_mechanic")
                .copied()
                .unwrap_or(0);
            op.evaluate(stacks as f64, *threshold as f64)
        }
        // ...
    }
}
```

#### 3.3 管线扩展（L4）

如需修改计算流程，修改 `pipeline.rs`：

```rust
// 示例：新增"伤害翻倍"机制（在 More 阶段之后）

// 1. 在 apply_modifications 后添加
let doubled_damages = if stat_pool.get_base("flag.damage_doubled") > 0.0 {
    modified_damages.iter()
        .map(|(k, v)| (k.clone(), DamageWithTags {
            min: v.min * 2.0,
            max: v.max * 2.0,
            ..v.clone()
        }))
        .collect()
} else {
    modified_damages
};

// 2. 更新后续计算使用 doubled_damages
```

#### 3.4 新增 ModifierKind（L4-L5）

```rust
// modifiers.rs
pub enum ModifierKind {
    Base,
    Increased,
    More,
    Flag,
    Override,
    // 新增
    Lucky,      // 伤害幸运
    Conversion, // 伤害转化
}
```

---

### Step 4: 测试验证

#### 4.1 单元测试模板

```rust
#[test]
fn test_new_mechanic_calculation() {
    let input = CalculatorInput {
        // ... 基础配置 ...
        mechanic_states: vec![
            MechanicState {
                id: "new_mechanic".to_string(),
                current_stacks: 5,
                max_stacks: 10,
                is_active: true,
            },
        ],
        mechanic_definitions: vec![
            MechanicDefinition {
                id: "new_mechanic".to_string(),
                display_name: "新机制".to_string(),
                category: "resource".to_string(),
                tag_key: "Mech_NewMechanic".to_string(),
                default_max_stacks: 10,
                base_effect_per_stack: HashMap::from([
                    ("mod.more.dmg.all".to_string(), 0.05),
                ]),
                description: "每层 +5% 全伤害".to_string(),
            },
        ],
        // ...
    };

    let result = calculate_dps(&input).expect("计算成功");
    
    // 验证机制效果
    // 5 层 × 5% = 25% More → 乘数 1.25
    assert!(result.damage_breakdown.multipliers.more_zone >= 1.25);
}
```

#### 4.2 集成测试（使用 MCP）

```typescript
// 通过 Supabase MCP 验证
const input = {
  mechanic_states: [{ id: "new_mechanic", current_stacks: 5, is_active: true }],
  mechanic_definitions: [/* 从数据库查询 */],
  // ...
};

const result = await calculate(JSON.stringify(input));
console.log("DPS:", result.dps_theoretical);
console.log("More Zone:", result.damage_breakdown.multipliers.more_zone);
```

---

## 4. Agent 协作 Prompt 指南

### 4.1 需求描述模板

```markdown
## 新增机制需求

### 机制概述
我需要实现 [机制名称] 机制，具体效果如下：
- [效果1描述]
- [效果2描述]
- 联动装备/天赋：[列出涉及的装备/天赋]

### 触发与条件
- 触发方式：[击中/击杀/始终生效/条件触发]
- 条件表达式（如有）：[condition_expr]
- 层数/持续时间：[描述]

### 计算规则
- 乘区类型：Inc / More / 独立乘区
- 生效阶段：[点伤/转化后/暴击前/...]
- 特殊规则：[如有]

### 涉及数据
请帮我：
1. 设计数据库表结构/数据
2. 确定属性键命名
3. 判断是否需要修改 Rust 代码
4. 编写测试用例验证
```

### 4.2 Agent A (数据层) Prompt

```markdown
## 数据层实现请求

请帮我在 Supabase 中实现以下机制的数据定义：

### 机制信息
- ID: {mechanic_id}
- 名称: {display_name}
- 分类: {category}

### 需要的数据操作
1. 检查 tags_registry 是否需要新增标签
2. 在 hero_traits 或 mechanics_registry 添加机制定义
3. 在 unique_items / unique_affixes 添加相关装备词缀
4. 生成 seed.sql 的 INSERT/UPSERT 语句

### 属性效果
- 每层效果: {base_effect_per_stack}
- 联动属性: {per_xxx 属性列表}

请使用 MCP 工具执行 SQL，并验证数据已正确插入。
```

### 4.3 Agent B (引擎层) Prompt

```markdown
## 引擎层实现请求

请帮我在 tli-core 中实现以下机制：

### 机制信息
- ID: {mechanic_id}
- 效果: {效果描述}
- 复杂度: L{1-5}

### 需要的代码修改

#### 如果是 L1-L3（仅数据驱动）
- 确认 mechanics.rs 已支持该效果类型
- 如需新条件，扩展 condition_ast.rs

#### 如果是 L4-L5（需要管线修改）
- 在 pipeline.rs 的 {具体阶段} 添加逻辑
- 如需新增 ModifierKind，修改 modifiers.rs

### 验证要求
1. 编写单元测试 test_{mechanic_id}_calculation
2. 运行 cargo test 确保所有测试通过
3. 输出测试结果中的关键数值
```

### 4.4 联调测试 Prompt

```markdown
## 机制联调测试

请使用以下配置进行完整的单元测试：

### 测试配置
- 主技能: {skill_id} lv.{level}
- 辅助技能: {support_skills}
- 装备: {items}
- 天赋: {traits}
- 机制状态: {mechanic_states}

### 预期结果
- 预期 DPS 范围: {min} - {max}
- 预期乘区贡献:
  - Inc Zone: {expected_inc}
  - More Zone: {expected_more}
  - {其他乘区}

### 验证步骤
1. 构造 CalculatorInput JSON
2. 调用 calculate_dps
3. 输出 DamageBreakdown.multipliers 各乘区数值
4. 对比预期，列出差异

如有计算偏差，请分析原因并修复。
```

---

## 5. 常见问题排查

| 问题 | 可能原因 | 排查方法 |
|------|---------|---------|
| 机制效果未生效 | `is_active = false` 或 `current_stacks = 0` | 检查 MechanicState |
| per_xxx 属性未计算 | 属性键命名错误 | 检查是否符合 `*.per_{mechanic_id}` 格式 |
| More 被当作 Inc | 属性键前缀错误 | 应使用 `mod.more.*` 而非 `mod.inc.*` |
| 条件不生效 | EvalContext 缺少数据 | 检查 context_flags/mechanic_stacks |
| 乘区溯源缺失 | ModDB 未记录来源 | 检查 StatAggregator.apply_stat 是否传递 source |

---

## 6. 快速参考

### 属性键速查

```
# 伤害类型
dmg.phys / dmg.fire / dmg.cold / dmg.lightning / dmg.chaos

# 修正类型
mod.inc.{key}     # Increased
mod.more.{key}    # More
mod.more.{key}.per_{mech}  # 每层 More

# 速度
speed.attack / speed.cast

# 暴击
crit.chance / crit.dmg

# 机制
flag.{name}                 # 布尔开关
mechanic.{id}.max_stacks    # 上限修改
```

### 条件表达式速查

```
# 布尔
is_moving == true
cannot_crit == false

# 数值比较
life_percent <= 0.35
fighting_will >= 50

# 标签检查
has_tag("Tag_Spell")
has_any_tag("Tag_Fire", "Tag_Cold")

# 机制检查
mechanic_active("focus_blessing")
mechanic_stacks("fighting_will") >= 50

# 复合
is_moving && life_percent <= 0.35
has_tag("Tag_Spell") || has_tag("Tag_Attack")
```

---

*本文档适用于 TLI v0.4.0+，基于 POB2 对标优化后的架构*

